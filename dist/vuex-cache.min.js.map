{"version":3,"file":"vuex-cache.min.js","sources":["../src/index.js"],"sourcesContent":["const isVuexStore = obj =>\n  'dispatch' in obj && typeof obj.dispatch === 'function'\n\n// convert string or obj to string\nconst toString = arg => (typeof arg === 'string' ? arg : JSON.stringify(arg))\n\n// convert arguments to string\nconst argsToString = args => {\n  let type = toString(args[0])\n  if (args[1]) {\n    type = `${type}:${toString(args[1])}`\n  }\n  return type\n}\n\n// parse timeout prop in option\nconst getTimeout = (args, option) => {\n  if (args.length === 1 && args[0].timeout) {\n    return args[0].timeout\n  }\n  if (args.length === 3 && args[2].timeout) {\n    return args[2].timeout\n  }\n  if (option && option.timeout) {\n    return option.timeout\n  }\n  return 0\n}\n\nconst cachePlugin = (store, option) => {\n  const cache = new Map()\n  // use another map to store timeout for each type\n  const timeoutCache = new Map()\n\n  cache.dispatch = (...args) => {\n    const type = argsToString(args)\n\n    const timeout = getTimeout(args, option)\n    if (timeout) {\n      const now = Date.now()\n      if (!timeoutCache.has(type)) {\n        timeoutCache.set(type, now)\n      } else {\n        const timeoutOfCurrentType = timeoutCache.get(type)\n        // console.log(now - timeout, timeoutOfCurrentType)\n        if (now - timeout > timeoutOfCurrentType) {\n          cache.delete(type)\n          timeoutCache.delete(type)\n        }\n      }\n    }\n\n    if (!cache.has(type)) {\n      const action = store.dispatch.apply(store, args).catch(error => {\n        cache.delete(type)\n        return Promise.reject(error)\n      })\n\n      cache.set(type, action)\n    }\n    return cache.get(type)\n  }\n\n  const _has = cache.has.bind(cache)\n  cache.has = (...args) => {\n    const key = argsToString(args)\n    return _has(toString(key))\n  }\n\n  const _delete = cache.delete.bind(cache)\n  cache.delete = (...args) => {\n    const key = argsToString(args)\n    return _delete(toString(key))\n  }\n\n  store.cache = cache\n}\n\nconst resolveParams = args => {\n  if (!isVuexStore(args)) {\n    return store => cachePlugin(store, args)\n  }\n  return cachePlugin(args)\n}\n\n// expose plugin as default\nexport default resolveParams\n\n// expose action enhancer\nexport function cacheAction(action) {\n  return function cacheEnhancedAction(context, payload) {\n    cachePlugin(context)\n    return action(context, payload)\n  }\n}\n"],"names":["toString","arg","JSON","stringify","argsToString","args","type","cachePlugin","store","option","cache","Map","timeoutCache","dispatch","timeout","length","getTimeout","now","Date","has","get","delete","set","action","apply","catch","error","Promise","reject","_has","bind","key","_delete","obj","context","payload"],"mappings":";;;;;4LAAA,IAIMA,EAAW,SAAAC,SAAuB,iBAARA,EAAmBA,EAAMC,KAAKC,UAAUF,IAGlEG,EAAe,SAAAC,OACfC,EAAON,EAASK,EAAK,WACrBA,EAAK,KACPC,YAAUA,cAAQN,EAASK,EAAK,MAE3BC,GAiBHC,EAAc,SAACC,EAAOC,OACpBC,EAAQ,IAAIC,IAEZC,EAAe,IAAID,IAEzBD,EAAMG,SAAW,sCAAIR,2BAAAA,sBACbC,EAAOF,EAAaC,GAEpBS,EArBS,SAACT,EAAMI,UACJ,IAAhBJ,EAAKU,QAAgBV,EAAK,GAAGS,QACxBT,EAAK,GAAGS,QAEG,IAAhBT,EAAKU,QAAgBV,EAAK,GAAGS,QACxBT,EAAK,GAAGS,QAEbL,GAAUA,EAAOK,QACZL,EAAOK,QAET,EAWWE,CAAWX,EAAMI,MAC7BK,EAAS,KACLG,EAAMC,KAAKD,SACZL,EAAaO,IAAIb,GAKhBW,EAAMH,EAFmBF,EAAaQ,IAAId,KAG5CI,EAAMW,OAAOf,GACbM,EAAaS,OAAOf,SANtBM,EAAaU,IAAIhB,EAAMW,OAWtBP,EAAMS,IAAIb,GAAO,KACdiB,EAASf,EAAMK,SAASW,MAAMhB,EAAOH,GAAMoB,MAAM,SAAAC,UACrDhB,EAAMW,OAAOf,GACNqB,QAAQC,OAAOF,KAGxBhB,EAAMY,IAAIhB,EAAMiB,UAEXb,EAAMU,IAAId,QAGbuB,EAAOnB,EAAMS,IAAIW,KAAKpB,GAC5BA,EAAMS,IAAM,sCAAId,2BAAAA,sBACR0B,EAAM3B,EAAaC,UAClBwB,EAAK7B,EAAS+B,SAGjBC,EAAUtB,EAAMW,OAAOS,KAAKpB,GAClCA,EAAMW,OAAS,sCAAIhB,2BAAAA,sBACX0B,EAAM3B,EAAaC,UAClB2B,EAAQhC,EAAS+B,KAG1BvB,EAAME,MAAQA,aAGM,SAAAL,SA7EpB,aADkB4B,EA+ED5B,IA9E4B,mBAAjB4B,EAAIpB,SAiFzBN,EAAYF,GAFV,SAAAG,UAASD,EAAYC,EAAOH,IAhFnB,IAAA4B,iBAyFb,SAAqBV,UACnB,SAA6BW,EAASC,UAC3C5B,EAAY2B,GACLX,EAAOW,EAASC"}